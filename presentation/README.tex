% Created 2025-07-29 Tue 06:08
% Intended LaTeX compiler: pdflatex
\documentclass[presentation,aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usetheme{metropolis}
\usecolortheme{seahorse}
\usefonttheme{professionalfonts}
\author{Architecture Guild Presentation}
\date{July 29, 2025}
\title{MAL Ruby Minimal: Extreme Constraints Drive Deep Understanding}
\subtitle{A Complete Lisp Interpreter Built with Only Cons Cells}
\definecolor{codeblue}{HTML}{0066CC}
\definecolor{codegray}{HTML}{586E75}
\hypersetup{
 pdfauthor={Architecture Guild Presentation},
 pdftitle={MAL Ruby Minimal: Extreme Constraints Drive Deep Understanding},
 pdfkeywords={Ruby, Lisp, Interpreter, Cons Cells, Functional Programming, Language Implementation},
 pdfsubject={Technical deep dive into building a complete Lisp interpreter using extreme minimalism constraints},
 pdfcreator={Emacs 30.1 (Org mode 9.7.11)}, 
 pdflang={English}}
\begin{document}

\maketitle
\begin{frame}{Outline}
\tableofcontents
\end{frame}

\section{Introduction}
\label{sec:org830788d}

\begin{frame}[label={sec:org7494e23}]{What We Built}
\begin{center}
A complete Lisp interpreter in Ruby with \alert{extreme constraints}
\end{center}

\begin{itemize}
\item X No Ruby arrays, hashes, or blocks
\item + Only cons cells (pairs) for all data structures
\item + Complete MAL (Make a Lisp) implementation
\item + Self-hosting capability
\item + 141/141 tests passing
\end{itemize}

\pause

\begin{center}
\alert{Result}: Demonstrates constraint-driven design while teaching fundamental CS
\end{center}
\end{frame}
\begin{frame}[label={sec:org98a987e}]{Why This Matters for Staff+ Engineers}
\begin{itemize}[<+->]
\item \alert{Constraint-driven design}: Forces architectural clarity
\item \alert{Performance trade-offs}: Explicit costs vs benefits
\item \alert{Language theory}: Church encoding in production Ruby
\item \alert{Educational value}: Onboarding and knowledge transfer
\item \alert{Empirical validation}: Minimal subset approach effectiveness
\end{itemize}

\pause

\begin{center}
\alert{Question}: Can everything really be built from just pairs?
\end{center}

\pause

\begin{center}
\alert{Answer}: Yes. Here's the proof.
\end{center}
\end{frame}
\section{Architecture Deep Dive}
\label{sec:orgaa238eb}

\begin{frame}[label={sec:org5cc9034},fragile]{Core Innovation: Pure Cons Cells}
 \begin{minted}[bgcolor=codegray!10,fontsize=\scriptsize,linenos=true]{ruby}
def cons(car_val, cdr_val)
  pair = Object.new
  pair.instance_variable_set(:@car, car_val)
  pair.instance_variable_set(:@cdr, cdr_val)

  # Dynamic method definition
  eval <<-RUBY
    def pair.car; @car; end
    def pair.cdr; @cdr; end
    def pair.pair?; true; end
  RUBY
  pair
end
\end{minted}

\pause

\alert{Everything emerges from this}:
\begin{itemize}
\item Lists: Nested pairs with nil terminator
\item Environments: Association lists
\item ASTs: Tree structures of pairs
\end{itemize}
\end{frame}
\begin{frame}[label={sec:orgb198a53},fragile]{Memory Layout Analysis}
 \begin{center}
List \texttt{(1 2 3)} memory representation:
\end{center}

\begin{verbatim}
┌─────┬─────┐    ┌─────┬─────┐    ┌─────┬─────┐
│  1  │  •──┼───►│  2  │  •──┼───►│  3  │ nil │
└─────┴─────┘    └─────┴─────┘    └─────┴─────┘
\end{verbatim}

\pause

\alert{Performance Impact}:
\begin{itemize}
\item Each cons: \textasciitilde{}256 bytes (Ruby object + methods)
\item Ruby Array: \textasciitilde{}8 bytes per element
\item \alert{Trade-off}: 32x memory overhead for educational clarity
\end{itemize}

\pause

\alert{Staff+ Insight}: Explicit performance costs enable informed decisions
\end{frame}
\begin{frame}[label={sec:org73eccae},fragile]{Tail Call Optimization Without Ruby TCO}
 Ruby doesn't guarantee TCO, so we implement it manually:

\begin{minted}[bgcolor=codegray!10,fontsize=\scriptsize,linenos=true]{ruby}
def EVAL(ast, env)
  loop do  # Trampoline pattern
    case ast
    when Integer, String
      return ast
    when Symbol  
      return env.get(ast.name)
    when List
      if tail_position?
        ast = new_ast  # Rebind instead of recurse
        env = new_env  # Loop continues - reuses stack frame
      else
        return EVAL(new_ast, new_env)
      end
    end
  end
end
\end{minted}

\alert{Key}: Loop + variable rebinding = manual stack management
\end{frame}
\begin{frame}[label={sec:orgd9f8cbb},fragile]{Environment as Persistent Data Structure}
 \begin{minted}[bgcolor=codegray!10,fontsize=\scriptsize,linenos=true]{ruby}
class Env
  def initialize(outer = nil)
    @data = nil    # Association list: ((x . 10) (y . 20))
    @outer = outer # Lexical scope chain
  end

  def set(key, value)
    @data = cons(cons(key, value), @data)
    # Original @data still exists - structural sharing!
  end

  def get(key)
    binding = assoc(key, @data)
    binding ? cdr(binding) : @outer&.get(key)
  end
end
\end{minted}

\alert{Benefits}:
\begin{itemize}
\item Natural closure implementation
\item Time-travel debugging capability
\item Immutable by design
\end{itemize}
\end{frame}
\section{Empirical AST Analysis}
\label{sec:org0693629}

\begin{frame}[label={sec:orgb4bbefa}]{Large-Scale Study: 412 Ruby Files Analyzed}
We conducted comprehensive analysis across major Ruby codebases:

\begin{center}
\begin{center}
\begin{tabular}{llrll}
Codebase & Domain & Files & Total Nodes & Unique Types\\
\hline
\alert{MAL} & Interpreter & 32 & 12,000+ & 60 types\\
Rails & Framework & 50 & 15,000+ & 72 types\\
ActiveAdmin & Web Framework & 50 & 12,000+ & 72 types\\
Shopify & E-commerce & 50+ & 18,000+ & 76+ types\\
\end{tabular}
\end{center}
\end{center}

\pause

\begin{center}
\alert{Finding}: Real Ruby uses 88+ unique AST node types

\alert{Our Achievement}: Complete interpreter with minimal subset
\end{center}
\end{frame}
\begin{frame}[label={sec:orgf5084dc},fragile]{Universal Patterns Discovered}
 \begin{enumerate}[<+->]
\item \alert{Method Dispatch Dominance}: \texttt{send} nodes account for 21-29\% across ALL codebases
\item \alert{Variable Management}: \texttt{lvar} consistently 8-22\% (lexical scoping essential)
\item \alert{Domain-Specific Variations}:
\begin{itemize}
\item \alert{Interpreters} (MAL): Heavy string processing (13\% vs 3\% typical)
\item \alert{Web Frameworks}: More constants/configuration (9.2\%)
\item \alert{CLI Tools}: Balanced distribution
\item \alert{Business Logic}: Heavy constant usage
\end{itemize}
\end{enumerate}

\pause

\alert{Staff+ Takeaway}: Language patterns transcend domains
\end{frame}
\begin{frame}[label={sec:org39277c3}]{MAL AST Progression: Deep Dive Analysis}
\begin{center}
\alert{Empirical Analysis}: Node usage across all MAL implementation steps
\end{center}

\begin{center}
\begin{center}
\begin{tabular}{rllrr}
Step & File Size & Total Nodes & Unique Types & Growth Factor\\
\hline
0 & 11.7KB & 55 & 19 & baseline\\
1 & 16.2KB & 77 & 25 & 1.38x\\
2 & 83.4KB & 379 & 33 & 5.15x\\
4 & 269.6KB & 1,068 & 38 & 1.94x\\
9 & 768.6KB & 2,383 & 43 & 1.23x\\
A & 1.5MB & 3,713 & 43 & 1.97x\\
\end{tabular}
\end{center}
\end{center}

\pause

\alert{Critical Discovery}: Step 2 shows 5.15x complexity jump (evaluation logic)
\end{frame}
\begin{frame}[label={sec:orgf866da9}]{Wild Ruby Validation: Dual-Parser Discovery}
\begin{center}
\alert{Large-Scale Analysis}: 500 random files from 53k+ Ruby corpus
\end{center}

\begin{itemize}[<+->]
\item \alert{Ruby Parser}: 72 unique node types (65.3\% coverage by our MAL)
\item \alert{Prism Parser}: 99 unique node types (53.5\% coverage by our MAL)
\item \alert{True Ceiling}: \textasciitilde{}99 node types for real-world Ruby code
\item \alert{Parser Difference}: Prism reveals 37\% more AST detail than Ruby's built-in parser
\end{itemize}

\pause

\alert{Validation}: Our minimal subset captures Ruby's computational essence effectively while missing mainly OOP/module patterns unnecessary for Lisp interpretation
\end{frame}
\section{Implementation Patterns}
\label{sec:org84fc890}

\begin{frame}[label={sec:orgb612dcc},fragile]{Metaprogramming Mastery}
 Our implementation leverages Ruby's dynamic features:

\begin{minted}[bgcolor=codegray!10,fontsize=\scriptsize,linenos=true]{ruby}
# Pattern 1: Dynamic method definition (52 occurrences)
eval <<-RUBY
  def obj.method_name; @value; end
RUBY

# Pattern 2: Instance variable metaprogramming (41 occurrences)  
obj.instance_variable_set(:@key, value)

# Pattern 3: Respond-to checking (23 occurrences)
obj.respond_to?(:method_name) && obj.method_name
\end{minted}

\alert{Trade-off}: Runtime flexibility vs compile-time safety

\alert{Staff+ Decision}: When is metaprogramming worth the complexity?
\end{frame}
\begin{frame}[label={sec:org580cfc4}]{Recursive by Nature}
\alert{Function Call Distribution} in our codebase:
\begin{itemize}
\item Direct recursion: 127 instances
\item Mutual recursion: 34 instances
\item TCO conversions: 8 critical functions
\end{itemize}

\pause

\alert{Pattern}: Recursive descent parser + Recursive evaluator = Naturally recursive codebase

\alert{Lesson}: Problem domain drives architectural patterns
\end{frame}
\begin{frame}[label={sec:orgd8051f8},fragile]{Control Flow Minimalism}
 \alert{Surprising Discovery}: Only 815 \texttt{if} nodes across 20,783 total nodes (3.9\%)

\pause

\alert{Why so few conditionals?}
\begin{itemize}
\item Most logic in method dispatch (\texttt{case} statements)
\item Lisp's uniform syntax reduces branching
\item Dynamic dispatch handles type variations
\end{itemize}

\pause

\alert{Staff+ Insight}: Well-designed abstractions reduce complexity
\end{frame}
\section{Educational Impact}
\label{sec:org41a8412}

\begin{frame}[label={sec:org4a614bf}]{Learning Through Constraints}
\alert{Hypothesis}: Extreme constraints force deep understanding

\alert{Validation}:
\begin{itemize}
\item No arrays/hashes → Master fundamental data structures
\item No blocks → Understand recursion and control flow
\item Cons-cell only → Reveal essence of computation
\end{itemize}

\pause

\alert{Results}:
\begin{itemize}
\item 15+ comprehensive guides created
\item 3-level tutorial progression (beginner → advanced)
\item Complete test coverage (141 tests)
\item Architecture guild presentation quality
\end{itemize}
\end{frame}
\begin{frame}[label={sec:org64cf0b3},fragile]{Progressive Complexity: Universal Node Analysis}
 \alert{19 Universal Nodes} appear in every MAL step:
\begin{verbatim}
NODE_ARGS, NODE_BLOCK, NODE_BREAK, NODE_CALL, NODE_DASGN
NODE_DEFN, NODE_DVAR, NODE_FCALL, NODE_GVAR, NODE_IF
NODE_ITER, NODE_LIST, NODE_LVAR, NODE_NEXT, NODE_NIL
NODE_OPCALL, NODE_SCOPE, NODE_STR, NODE_VCALL
\end{verbatim}

\pause

\alert{Node Evolution Timeline}:
\begin{itemize}
\item Step 0: 19 baseline nodes (minimal Ruby)
\item Step 2: +8 nodes (evaluation: CASE, CONST, HASH, LIT)
\item Step 4: +5 nodes (functions: FALSE, SPLAT, WHILE)
\item Step 9: +3 nodes (OOP: CLASS, IASGN, SUPER)
\end{itemize}

\alert{Pedagogical Insight}: Each feature addition requires specific AST support
\end{frame}
\section{Performance Analysis}
\label{sec:org7f197c2}

\begin{frame}[label={sec:org69e4c45}]{Algorithmic Complexity Trade-offs}
\begin{center}
\begin{center}
\begin{tabular}{llll}
Operation & Our Implementation & Optimized Lisp & Ruby Native\\
\hline
cons & O(1) & O(1) & N/A\\
car/cdr & O(1) & O(1) & O(1)\\
nth element & O(n) & O(1)* & O(1)\\
env lookup & O(n×m) & O(log n) & O(1)\\
append & O(n) & O(n) & O(1) amortized\\
\end{tabular}
\end{center}
\end{center}

\alert{Staff+ Decision Matrix}: Clarity vs Performance

\alert{When to choose clarity}: Education, prototyping, correctness validation
\end{frame}
\begin{frame}[label={sec:orgf72f475}]{Memory vs Clarity Trade-off}
\begin{itemize}[<+->]
\item \alert{Memory overhead}: 32x vs Ruby arrays
\item \alert{Execution speed}: 10-100x slower than optimized Lisps
\item \alert{Development time}: 2x longer due to constraints
\item \alert{Understanding depth}: 10x deeper than conventional approach
\end{itemize}

\pause

\alert{Staff+ Lesson}: Make trade-offs explicit and intentional
\end{frame}
\section{Theoretical Validation}
\label{sec:orgd9de9c4}

\begin{frame}[label={sec:org95d740c},fragile]{Church-Turing Completeness Proof}
 Our implementation demonstrates:

\begin{enumerate}
\item \alert{Universal Computation}: Can express any algorithm in MAL
\item \alert{Self-Hosting Capability}: Can run MAL-in-MAL (bootstrapping)
\item \alert{Minimal Sufficient Set}: Cons cells + functions = complete language
\end{enumerate}

\pause

\alert{Lambda Calculus Foundation}:
\begin{verbatim}
cons(a,b) ≡ λf.f a b     (Church pair)
car(p)    ≡ p (λxy.x)    (First projection)  
cdr(p)    ≡ p (λxy.y)    (Second projection)
\end{verbatim}

\pause

\alert{Practical Impact}: Theory informs implementation decisions
\end{frame}
\begin{frame}[label={sec:orge16eed2},fragile]{Denotational Semantics}
 Our evaluator implements classic semantic equations:

\begin{verbatim}
⟦n⟧ = n                              (numbers → themselves)
⟦x⟧ρ = ρ(x)                          (variables → environment lookup)  
⟦(f e₁...eₙ)⟧ρ = ⟦f⟧ρ(⟦e₁⟧ρ,...,⟦eₙ⟧ρ)   (application)
⟦(lambda (x) e)⟧ρ = λv.⟦e⟧ρ[x↦v]      (abstraction)
\end{verbatim}

\alert{Staff+ Value}: Formal foundations guide implementation correctness
\end{frame}
\section{Key Takeaways}
\label{sec:orgeefb6d0}

\begin{frame}[label={sec:org6a7ac8e}]{For Staff+ Engineers}
\begin{enumerate}[<+->]
\item \alert{Constraints Drive Innovation}: Limitations force creative solutions
\item \alert{Make Trade-offs Explicit}: Document performance vs clarity decisions
\item \alert{Theory Matters}: Formal foundations prevent architectural mistakes
\item \alert{Education Investment}: Teaching tools multiply team effectiveness
\item \alert{Ruby's Power}: Metaprogramming enables constraint-driven design
\end{enumerate}

\pause

\alert{Actionable}: Apply constraint-driven design to your next architecture
\end{frame}
\begin{frame}[label={sec:org53899b2},fragile]{For Ruby Developers}
 \begin{itemize}[<+->]
\item \alert{Minimal Subset Validated}: Educational constraints drive deep learning
\item \alert{Method Dispatch Central}: Design APIs around \texttt{send} patterns
\item \alert{Metaprogramming Justified}: When constraints require flexibility
\item \alert{Performance Conscious}: Measure, don't guess overhead costs
\item \alert{Educational ROI}: Investment in understanding pays dividends
\end{itemize}

\pause

\alert{Challenge}: What constraints could improve your current project?
\end{frame}
\section{Demo \& Discussion}
\label{sec:orgca2646b}

\begin{frame}[label={sec:orgca6ccc3},fragile]{Live Demo}
 \begin{center}
Let's see the interpreter in action
\end{center}

\begin{minted}[bgcolor=codegray!10,fontsize=\scriptsize,linenos=true]{bash}
$ ruby mal_minimal.rb
mal-user> (def! factorial 
            (fn* (n) 
              (if (< n 2) 1 
                  (* n (factorial (- n 1))))))
#<function>

mal-user> (factorial 10)
3628800

mal-user> (map (fn* (x) (* x x)) (list 1 2 3 4 5))
(1 4 9 16 25)
\end{minted}
\end{frame}
\begin{frame}[label={sec:orga54c1cf}]{Questions \& Discussion}
\begin{center}
\alert{Repository}: \url{https://github.com/aygp-dr/mal-ruby-minimal}

\alert{Key Resources}:
\begin{itemize}
\item Complete implementation (steps 0-A)
\item 15+ documentation guides
\item Comprehensive test suite
\item AST analysis experiment
\item Architecture review document
\end{itemize}
\end{center}

\pause

\begin{center}
\alert{Discussion Topics}:
\begin{itemize}
\item Constraint-driven design in your projects?
\item Trade-off decisions you've made?
\item Educational tools for your teams?
\end{itemize}
\end{center}
\end{frame}
\section{Appendix}
\label{sec:org017f59f}

\begin{frame}[label={sec:orge2c90ca}]{Implementation Statistics}
\begin{center}
\alert{Project Metrics}:
\begin{itemize}
\item 2,500+ lines of Ruby code
\item 141 unit + integration tests (100\% pass rate)
\item 15 documentation files (\textasciitilde{}50 pages)
\item 9 essential node types used (minimal subset approach)
\item 32x memory overhead (explicit trade-off)
\item 2-week development timeline
\end{itemize}
\end{center}
\end{frame}
\begin{frame}[label={sec:orgf519866}]{Future Directions}
\alert{Performance Optimizations}:
\begin{itemize}
\item String/symbol interning (40\% memory reduction)
\item Bytecode compilation for hot paths
\item Custom allocator for cons cells
\end{itemize}

\alert{Language Extensions}:
\begin{itemize}
\item Type system with inference
\item Concurrency with actor model
\item Module system for namespaces
\end{itemize}

\alert{Educational Enhancements}:
\begin{itemize}
\item Visual debugger with step execution
\item Performance profiler integration
\item Interactive tutorial system
\end{itemize}
\end{frame}
\end{document}
