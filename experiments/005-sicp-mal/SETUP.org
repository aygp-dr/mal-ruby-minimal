#+TITLE: SICP Examples in MAL Lisp
#+AUTHOR: MAL SICP Study Guide
#+DATE: 2025-07-29
#+PROPERTY: header-args:lisp :tangle-mode (identity #o755) :mkdirp yes
#+PROPERTY: header-args:mermaid :exports results :results file

* SICP Chapter 1 - Building Abstractions with Procedures

** Section 1.1 - The Elements of Programming

*** Basic Examples

#+begin_src lisp :tangle ./chapter1_basics.mal
;; SICP Chapter 1.1 - Basic Elements
;; Translated to MAL Lisp

;; 1.1.1 Expressions
(+ 137 349)  ; => 486
(- 1000 334) ; => 666
(* 5 99)     ; => 495
(/ 10 5)     ; => 2
(+ 2.7 10)   ; => 12.7

;; Nested combinations
(+ (* 3 5) (- 10 6))  ; => 19

;; 1.1.2 Naming and the Environment
(def! size 2)
(def! pi 3.14159)
(def! radius 10)
(def! circumference (* 2 pi radius))  ; => 62.8318

;; 1.1.4 Compound Procedures
(def! square (fn* [x] (* x x)))
(square 21)  ; => 441
(square (+ 2 5))  ; => 49
(square (square 3))  ; => 81

(def! sum-of-squares (fn* [x y]
  (+ (square x) (square y))))
(sum-of-squares 3 4)  ; => 25

(def! f (fn* [a]
  (sum-of-squares (+ a 1) (* a 2))))
(f 5)  ; => 136
#+end_src

*** Conditional Expressions and Predicates

#+begin_src lisp :tangle ./chapter1_conditionals.mal
;; SICP 1.1.6 - Conditional Expressions

(def! abs (fn* [x]
  (cond (> x 0) x
        (= x 0) 0
        (< x 0) (- x))))

;; Alternative definition using if
(def! abs2 (fn* [x]
  (if (< x 0)
      (- x)
      x)))

;; Exercise 1.3: Sum of squares of two larger numbers
(def! sum-squares-larger (fn* [x y z]
  (cond (and (<= x y) (<= x z)) (sum-of-squares y z)
        (and (<= y x) (<= y z)) (sum-of-squares x z)
        :else (sum-of-squares x y))))

;; Exercise 1.4: Compound expression with operator as result
(def! a-plus-abs-b (fn* [a b]
  ((if (> b 0) + -) a b)))

;; Test predicates
(def! positive? (fn* [x] (> x 0)))
(def! negative? (fn* [x] (< x 0)))
(def! zero? (fn* [x] (= x 0)))
#+end_src

** Section 1.2 - Procedures and the Processes They Generate

*** Linear Recursion and Iteration

#+begin_src lisp :tangle ./chapter1_recursion.mal
;; SICP 1.2.1 - Linear Recursion and Iteration

;; Factorial - Recursive Process
(def! factorial (fn* [n]
  (if (= n 1)
      1
      (* n (factorial (- n 1))))))

;; Factorial - Iterative Process
(def! fact-iter (fn* [product counter max-count]
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count))))

(def! factorial-iter (fn* [n]
  (fact-iter 1 1 n)))

;; Exercise 1.9 - Two models of addition
;; Recursive process
(def! plus-recursive (fn* [a b]
  (if (= a 0)
      b
      (inc (plus-recursive (dec a) b)))))

;; Iterative process
(def! plus-iterative (fn* [a b]
  (if (= a 0)
      b
      (plus-iterative (dec a) (inc b)))))

;; Helper functions for above
(def! inc (fn* [n] (+ n 1)))
(def! dec (fn* [n] (- n 1)))
#+end_src

*** Tree Recursion

#+begin_src lisp :tangle ./chapter1_tree_recursion.mal
;; SICP 1.2.2 - Tree Recursion

;; Fibonacci - Tree Recursive Process
(def! fib (fn* [n]
  (cond (= n 0) 0
        (= n 1) 1
        :else (+ (fib (- n 1))
                 (fib (- n 2))))))

;; Fibonacci - Iterative Process
(def! fib-iter (fn* [a b count]
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1)))))

(def! fib-iterative (fn* [n]
  (fib-iter 1 0 n)))

;; Counting change - SICP classic example
(def! count-change (fn* [amount]
  (cc amount 5)))

(def! cc (fn* [amount kinds-of-coins]
  (cond (= amount 0) 1
        (or (< amount 0) (= kinds-of-coins 0)) 0
        :else (+ (cc amount (- kinds-of-coins 1))
                 (cc (- amount (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(def! first-denomination (fn* [kinds-of-coins]
  (cond (= kinds-of-coins 1) 1
        (= kinds-of-coins 2) 5
        (= kinds-of-coins 3) 10
        (= kinds-of-coins 4) 25
        (= kinds-of-coins 5) 50)))

;; Exercise 1.11
(def! f-recursive (fn* [n]
  (if (< n 3)
      n
      (+ (f-recursive (- n 1))
         (* 2 (f-recursive (- n 2)))
         (* 3 (f-recursive (- n 3)))))))

(def! f-iterative (fn* [n]
  (f-iter 2 1 0 n)))

(def! f-iter (fn* [a b c count]
  (if (= count 0)
      c
      (f-iter (+ a (* 2 b) (* 3 c))
              a
              b
              (- count 1)))))
#+end_src

** Section 1.3 - Higher-Order Procedures

*** Procedures as Arguments

#+begin_src lisp :tangle ./chapter1_higher_order.mal
;; SICP 1.3.1 - Procedures as Arguments

;; Summation abstraction
(def! sum (fn* [term a next b]
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b)))))

;; Using sum to define specific sums
(def! identity (fn* [x] x))

(def! sum-integers (fn* [a b]
  (sum identity a inc b)))

(def! cube (fn* [x] (* x x x)))

(def! sum-cubes (fn* [a b]
  (sum cube a inc b)))

;; Pi approximation using sum
(def! pi-sum (fn* [a b]
  (sum pi-term a pi-next b)))

(def! pi-term (fn* [x]
  (/ 1.0 (* x (+ x 2)))))

(def! pi-next (fn* [x]
  (+ x 4)))

;; Definite integral approximation
(def! integral (fn* [f a b dx]
  (* (sum f (+ a (/ dx 2.0))
            (fn* [x] (+ x dx))
            b)
     dx)))

;; Simpson's Rule - Exercise 1.29
(def! simpson (fn* [f a b n]
  (let* [h (/ (- b a) n)
         y (fn* [k] (f (+ a (* k h))))
         simpson-term (fn* [k]
           (* (cond (or (= k 0) (= k n)) 1
                    (odd? k) 4
                    :else 2)
              (y k)))]
    (* (/ h 3) (sum simpson-term 0 inc n)))))

(def! odd? (fn* [n] (= (mod n 2) 1)))
(def! even? (fn* [n] (= (mod n 2) 0)))
#+end_src

*** Constructing Procedures Using Lambda

#+begin_src lisp :tangle ./chapter1_lambda.mal
;; SICP 1.3.2 - Constructing Procedures Using Lambda

;; Pi sum using lambda
(def! pi-sum-lambda (fn* [a b]
  (sum (fn* [x] (/ 1.0 (* x (+ x 2))))
       a
       (fn* [x] (+ x 4))
       b)))

;; Integral with lambda
(def! integral-lambda (fn* [f a b dx]
  (let* [add-dx (fn* [x] (+ x dx))]
    (* (sum f (+ a (/ dx 2)) add-dx b)
       dx))))

;; Let as lambda application
;; MAL already has let*, but here's how it works conceptually
(def! f-with-let (fn* [x y]
  (let* [a (+ 1 (* x y))
         b (- 1 y)]
    (+ (* x (square a))
       (* y b)
       (* a b)))))

;; Equivalent using lambda (for demonstration)
(def! f-with-lambda (fn* [x y]
  ((fn* [a b]
     (+ (* x (square a))
        (* y b)
        (* a b)))
   (+ 1 (* x y))
   (- 1 y))))
#+end_src

*** Procedures as Returned Values

#+begin_src lisp :tangle ./chapter1_procedures_as_values.mal
;; SICP 1.3.3 & 1.3.4 - Procedures as Return Values

;; Average damping
(def! average (fn* [x y] (/ (+ x y) 2)))

(def! average-damp (fn* [f]
  (fn* [x] (average x (f x)))))

;; Fixed point
(def! tolerance 0.00001)

(def! fixed-point (fn* [f first-guess]
  (let* [close-enough? (fn* [v1 v2]
                         (< (abs (- v1 v2)) tolerance))
         try (fn* [guess]
               (let* [next (f guess)]
                 (if (close-enough? guess next)
                     next
                     (try next))))]
    (try first-guess))))

;; Square root using fixed point
(def! sqrt-fixed-point (fn* [x]
  (fixed-point (average-damp (fn* [y] (/ x y)))
               1.0)))

;; Newton's method
(def! deriv (fn* [g]
  (let* [dx 0.00001]
    (fn* [x]
      (/ (- (g (+ x dx)) (g x))
         dx)))))

(def! newton-transform (fn* [g]
  (fn* [x]
    (- x (/ (g x) ((deriv g) x))))))

(def! newtons-method (fn* [g guess]
  (fixed-point (newton-transform g) guess)))

(def! sqrt-newton (fn* [x]
  (newtons-method (fn* [y] (- (square y) x))
                   1.0)))

;; Fixed point of transforms
(def! fixed-point-of-transform (fn* [g transform guess]
  (fixed-point (transform g) guess)))

;; Exercise 1.40
(def! cubic (fn* [a b c]
  (fn* [x]
    (+ (cube x)
       (* a (square x))
       (* b x)
       c))))

;; Exercise 1.41 - Double
(def! double (fn* [f]
  (fn* [x] (f (f x)))))

;; ((double (double double)) inc) 0) => 16

;; Exercise 1.42 - Compose
(def! compose (fn* [f g]
  (fn* [x] (f (g x)))))

;; Exercise 1.43 - Repeated
(def! repeated (fn* [f n]
  (if (= n 1)
      f
      (compose f (repeated f (- n 1))))))
#+end_src

* SICP Chapter 2 - Building Abstractions with Data

** Section 2.1 - Introduction to Data Abstraction

*** Church Numerals from SICP Exercise 2.6

#+begin_src lisp :tangle ./chapter2_church_numerals.mal
;; SICP Exercise 2.6 - Church Numerals
;; In honor of Alonzo Church, representations of
;; non-negative integers using only procedures

;; Church zero and successor
(def! church-zero (fn* [f] (fn* [x] x)))

(def! church-add-1 (fn* [n]
  (fn* [f] (fn* [x] (f ((n f) x))))))

;; Direct definitions
(def! church-one (fn* [f] (fn* [x] (f x))))
(def! church-two (fn* [f] (fn* [x] (f (f x)))))

;; Verification that add-1 works
;; (church-add-1 church-zero) should equal church-one
;; Substitution proof as in SICP

;; Addition of Church numerals
(def! church-+ (fn* [m n]
  (fn* [f] (fn* [x] ((m f) ((n f) x))))))

;; Multiplication (Exercise continuation)
(def! church-* (fn* [m n]
  (fn* [f] (m (n f)))))

;; Exponentiation
(def! church-expt (fn* [m n]
  (n m)))

;; Convert Church numeral to integer for testing
(def! church->int (fn* [n]
  ((n (fn* [x] (+ x 1))) 0)))

;; Tests
(def! test-church-numerals (fn* []
  (println "Church numeral tests:")
  (println (str "  zero = " (church->int church-zero)))
  (println (str "  one = " (church->int church-one)))
  (println (str "  two = " (church->int church-two)))
  (println (str "  1 + 1 = " (church->int (church-+ church-one church-one))))
  (println (str "  2 * 3 = " (church->int (church-* church-two 
                                                      (church-add-1 church-two)))))
  (println (str "  2^3 = " (church->int (church-expt church-two 
                                                     (church-add-1 church-two)))))))
#+end_src

** Section 2.1.3 - What Is Meant by Data?

*** Procedural Representation of Pairs

#+begin_src lisp :tangle ./chapter2_pairs.mal
;; SICP 2.1.3 - Procedural Representation of Pairs

;; Exercise 2.4 - Alternative pair representation
(def! cons-proc (fn* [x y]
  (fn* [m] (m x y))))

(def! car-proc (fn* [z]
  (z (fn* [p q] p))))

(def! cdr-proc (fn* [z]
  (z (fn* [p q] q))))

;; Verification by substitution (as shown in SICP)
;; (car-proc (cons-proc x y))
;; = (car-proc (fn* [m] (m x y)))
;; = ((fn* [m] (m x y)) (fn* [p q] p))
;; = ((fn* [p q] p) x y)
;; = x

;; Exercise 2.5 - Pairs as products of powers
(def! cons-num (fn* [a b]
  (* (expt 2 a) (expt 3 b))))

(def! car-num (fn* [z]
  (if (= (mod z 2) 0)
      (+ 1 (car-num (/ z 2)))
      0)))

(def! cdr-num (fn* [z]
  (if (= (mod z 3) 0)
      (+ 1 (cdr-num (/ z 3)))
      0)))

;; Helper for exponentiation
(def! expt (fn* [base exp]
  (if (= exp 0)
      1
      (* base (expt base (- exp 1))))))

;; Exercise 2.6 extension - Church pairs
(def! church-cons (fn* [x y]
  (fn* [m] (m x y))))

(def! church-car (fn* [z]
  (z church-true)))

(def! church-cdr (fn* [z]
  (z church-false)))

;; Where church-true/false are from previous section
(def! church-true (fn* [x y] x))
(def! church-false (fn* [x y] y))
#+end_src

** Section 2.2 - Hierarchical Data

*** List Operations

#+begin_src lisp :tangle ./chapter2_lists.mal
;; SICP 2.2.1 - Representing Sequences

;; List operations (MAL has built-in list ops, but let's implement SICP style)
(def! list-ref (fn* [items n]
  (if (= n 0)
      (first items)
      (list-ref (rest items) (- n 1)))))

(def! length (fn* [items]
  (if (empty? items)
      0
      (+ 1 (length (rest items))))))

(def! length-iter (fn* [items]
  (let* [iter (fn* [a count]
                (if (empty? a)
                    count
                    (iter (rest a) (+ 1 count))))]
    (iter items 0))))

(def! append (fn* [list1 list2]
  (if (empty? list1)
      list2
      (cons (first list1) (append (rest list1) list2)))))

;; Exercise 2.17 - Last pair
(def! last-pair (fn* [items]
  (if (empty? (rest items))
      items
      (last-pair (rest items)))))

;; Exercise 2.18 - Reverse
(def! reverse (fn* [items]
  (if (empty? items)
      '()
      (append (reverse (rest items))
              (list (first items))))))

;; Exercise 2.20 - Same parity
(def! same-parity (fn* [x & others]
  (let* [same? (if (even? x) even? odd?)
         filter-parity (fn* [items]
                         (cond (empty? items) '()
                               (same? (first items))
                                 (cons (first items)
                                       (filter-parity (rest items)))
                               :else (filter-parity (rest items))))]
    (cons x (filter-parity others)))))

;; Mapping over lists
(def! map-sicp (fn* [proc items]
  (if (empty? items)
      '()
      (cons (proc (first items))
            (map-sicp proc (rest items))))))

;; Exercise 2.21
(def! square-list (fn* [items]
  (if (empty? items)
      '()
      (cons (square (first items))
            (square-list (rest items))))))

(def! square-list-map (fn* [items]
  (map-sicp square items)))

;; Exercise 2.23 - for-each
(def! for-each (fn* [proc items]
  (if (not (empty? items))
      (do
        (proc (first items))
        (for-each proc (rest items))))))
#+end_src

*** Hierarchical Structures

#+begin_src lisp :tangle ./chapter2_trees.mal
;; SICP 2.2.2 - Hierarchical Structures

;; Count leaves in a tree
(def! count-leaves (fn* [x]
  (cond (nil? x) 0
        (not (list? x)) 1
        :else (+ (count-leaves (first x))
                 (count-leaves (rest x))))))

;; Exercise 2.24-2.29 - Trees and mobile
(def! deep-reverse (fn* [items]
  (cond (not (list? items)) items
        (empty? items) '()
        :else (append (deep-reverse (rest items))
                      (list (deep-reverse (first items)))))))

;; Tree mapping
(def! tree-map (fn* [proc tree]
  (map-sicp (fn* [sub-tree]
              (if (list? sub-tree)
                  (tree-map proc sub-tree)
                  (proc sub-tree)))
            tree)))

;; Exercise 2.31
(def! square-tree (fn* [tree]
  (tree-map square tree)))

;; Exercise 2.32 - Subsets
(def! subsets (fn* [s]
  (if (empty? s)
      (list '())
      (let* [rest (subsets (rest s))]
        (append rest (map-sicp (fn* [x] (cons (first s) x))
                               rest))))))
#+end_src

** Section 2.3 - Symbolic Data

### Symbolic Differentiation

#+begin_src lisp :tangle ./chapter2_symbolic.mal
;; SICP 2.3.2 - Symbolic Differentiation

;; Representation of algebraic expressions
(def! variable? (fn* [x] (symbol? x)))

(def! same-variable? (fn* [v1 v2]
  (and (variable? v1) (variable? v2) (= v1 v2))))

(def! make-sum (fn* [a1 a2]
  (cond (=number? a1 0) a2
        (=number? a2 0) a1
        (and (number? a1) (number? a2)) (+ a1 a2)
        :else (list '+ a1 a2))))

(def! make-product (fn* [m1 m2]
  (cond (or (=number? m1 0) (=number? m2 0)) 0
        (=number? m1 1) m2
        (=number? m2 1) m1
        (and (number? m1) (number? m2)) (* m1 m2)
        :else (list '* m1 m2))))

(def! =number? (fn* [exp num]
  (and (number? exp) (= exp num))))

(def! sum? (fn* [x]
  (and (list? x) (= (first x) '+))))

(def! addend (fn* [s] (nth s 1)))
(def! augend (fn* [s] (nth s 2)))

(def! product? (fn* [x]
  (and (list? x) (= (first x) '*))))

(def! multiplier (fn* [p] (nth p 1)))
(def! multiplicand (fn* [p] (nth p 2)))

;; The differentiator
(def! deriv (fn* [exp var]
  (cond (number? exp) 0
        (variable? exp)
          (if (same-variable? exp var) 1 0)
        (sum? exp)
          (make-sum (deriv (addend exp) var)
                    (deriv (augend exp) var))
        (product? exp)
          (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp)))
        :else
          (throw "unknown expression type -- DERIV"))))

;; Exercise 2.56 - Exponentiation
(def! exponentiation? (fn* [x]
  (and (list? x) (= (first x) '**))))

(def! base (fn* [e] (nth e 1)))
(def! exponent (fn* [e] (nth e 2)))

(def! make-exponentiation (fn* [base exp]
  (cond (=number? exp 0) 1
        (=number? exp 1) base
        (and (number? base) (number? exp)) (expt base exp)
        :else (list '** base exp))))

;; Extended deriv with exponentiation
(def! deriv-extended (fn* [exp var]
  (cond (number? exp) 0
        (variable? exp)
          (if (same-variable? exp var) 1 0)
        (sum? exp)
          (make-sum (deriv-extended (addend exp) var)
                    (deriv-extended (augend exp) var))
        (product? exp)
          (make-sum
            (make-product (multiplier exp)
                          (deriv-extended (multiplicand exp) var))
            (make-product (deriv-extended (multiplier exp) var)
                          (multiplicand exp)))
        (exponentiation? exp)
          (make-product
            (make-product (exponent exp)
                          (make-exponentiation (base exp)
                                               (make-sum (exponent exp) -1)))
            (deriv-extended (base exp) var))
        :else
          (throw "unknown expression type -- DERIV"))))

;; Test expressions
(def! test-deriv (fn* []
  (println "Derivative tests:")
  (println (str "  d/dx(x + 3) = " (deriv '(+ x 3) 'x)))
  (println (str "  d/dx(x * y) = " (deriv '(* x y) 'x)))
  (println (str "  d/dx(x * y + x + 3) = " 
                (deriv '(+ (* x y) (+ x 3)) 'x)))))
#+end_src

** Section 2.4 - Multiple Representations

### Message Passing Style

#+begin_src lisp :tangle ./chapter2_message_passing.mal
;; SICP 2.4 - Multiple Representations using Message Passing

;; Complex numbers - message passing style
(def! make-from-real-imag (fn* [x y]
  (let* [dispatch (fn* [op]
                    (cond (= op 'real-part) x
                          (= op 'imag-part) y
                          (= op 'magnitude)
                            (sqrt (+ (square x) (square y)))
                          (= op 'angle) (atan y x)
                          :else
                            (throw "Unknown op -- MAKE-FROM-REAL-IMAG")))]
    dispatch)))

(def! make-from-mag-ang (fn* [r a]
  (let* [dispatch (fn* [op]
                    (cond (= op 'real-part) (* r (cos a))
                          (= op 'imag-part) (* r (sin a))
                          (= op 'magnitude) r
                          (= op 'angle) a
                          :else
                            (throw "Unknown op -- MAKE-FROM-MAG-ANG")))]
    dispatch)))

;; Generic operations
(def! real-part (fn* [z] (z 'real-part)))
(def! imag-part (fn* [z] (z 'imag-part)))
(def! magnitude (fn* [z] (z 'magnitude)))
(def! angle (fn* [z] (z 'angle)))

;; Exercise 2.75 - Make-from-mag-ang in message-passing style
;; (Already implemented above)

;; Additional complex number operations
(def! add-complex (fn* [z1 z2]
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2)))))

(def! sub-complex (fn* [z1 z2]
  (make-from-real-imag (- (real-part z1) (real-part z2))
                       (- (imag-part z1) (imag-part z2)))))

(def! mul-complex (fn* [z1 z2]
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                     (+ (angle z1) (angle z2)))))

(def! div-complex (fn* [z1 z2]
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                     (- (angle z1) (angle z2)))))

;; Math functions (approximations for MAL)
(def! sqrt (fn* [x]
  (if (< x 0)
      (throw "sqrt of negative number")
      (fixed-point (average-damp (fn* [y] (/ x y))) 1.0))))

(def! cos (fn* [x] 
  ;; Taylor series approximation
  (- 1 (/ (* x x) 2) (/ (* x x x x) 24))))

(def! sin (fn* [x]
  ;; Taylor series approximation  
  (- x (/ (* x x x) 6) (/ (* x x x x x) 120))))

(def! atan (fn* [y x]
  ;; Simple approximation
  (/ y (+ x 0.0001))))  ; Avoid division by zero
#+end_src

* SICP Chapter 3 - Modularity, Objects, and State

** Section 3.1 - Assignment and Local State

#+begin_src lisp :tangle ./chapter3_state.mal
;; SICP 3.1 - Assignment and Local State
;; Note: MAL uses atoms for mutable state

;; Bank account with local state
(def! make-account (fn* [balance]
  (let* [bal (atom balance)]
    (fn* [m]
      (cond (= m 'withdraw)
              (fn* [amount]
                (if (>= @bal amount)
                    (do (swap! bal - amount)
                        @bal)
                    "Insufficient funds"))
            (= m 'deposit)
              (fn* [amount]
                (swap! bal + amount)
                @bal)
            (= m 'balance) @bal
            :else (throw "Unknown request -- MAKE-ACCOUNT"))))))

;; Usage:
;; (def! acc (make-account 100))
;; ((acc 'withdraw) 50)  ; => 50
;; ((acc 'deposit) 40)   ; => 90
;; (acc 'balance)        ; => 90

;; Exercise 3.1 - Accumulator
(def! make-accumulator (fn* [initial]
  (let* [sum (atom initial)]
    (fn* [value]
      (swap! sum + value)
      @sum))))

;; Exercise 3.2 - Monitored procedures
(def! make-monitored (fn* [f]
  (let* [count (atom 0)]
    (fn* [arg]
      (if (= arg 'how-many-calls?)
          @count
          (do (swap! count inc)
              (f arg)))))))

;; Exercise 3.3 - Password-protected account
(def! make-account-password (fn* [balance password]
  (let* [bal (atom balance)
         incorrect-attempts (atom 0)]
    (fn* [pass m]
      (if (= pass password)
          (do (reset! incorrect-attempts 0)
              (cond (= m 'withdraw)
                      (fn* [amount]
                        (if (>= @bal amount)
                            (do (swap! bal - amount)
                                @bal)
                            "Insufficient funds"))
                    (= m 'deposit)
                      (fn* [amount]
                        (swap! bal + amount)
                        @bal)
                    (= m 'balance) @bal
                    :else (throw "Unknown request")))
          (do (swap! incorrect-attempts inc)
              (if (>= @incorrect-attempts 7)
                  (fn* [x] "Call the cops!")
                  (fn* [x] "Incorrect password"))))))))
#+end_src

** Section 3.3 - Mutable Data

#+begin_src lisp :tangle ./chapter3_mutable.mal
;; SICP 3.3.1 - Mutable List Structure
;; MAL doesn't have set-car!/set-cdr!, so we'll use atoms

;; Mutable pairs using atoms
(def! mcons (fn* [x y]
  {:car (atom x) :cdr (atom y)}))

(def! mcar (fn* [z]
  @(:car z)))

(def! mcdr (fn* [z]
  @(:cdr z)))

(def! set-mcar! (fn* [z new-value]
  (reset! (:car z) new-value)))

(def! set-mcdr! (fn* [z new-value]
  (reset! (:cdr z) new-value)))

;; Queue implementation
(def! make-queue (fn* []
  (let* [front-ptr (atom '())
         rear-ptr (atom '())]
    {:front front-ptr :rear rear-ptr})))

(def! empty-queue? (fn* [queue]
  (empty? @(:front queue))))

(def! front-queue (fn* [queue]
  (if (empty-queue? queue)
      (throw "FRONT called with an empty queue")
      (first @(:front queue)))))

(def! insert-queue! (fn* [queue item]
  (let* [new-pair (list item)]
    (if (empty-queue? queue)
        (do (reset! (:front queue) new-pair)
            (reset! (:rear queue) new-pair))
        (do (reset! (:rear queue) 
                    (concat @(:rear queue) new-pair))))
    queue)))

(def! delete-queue! (fn* [queue]
  (if (empty-queue? queue)
      (throw "DELETE! called with an empty queue")
      (reset! (:front queue) (rest @(:front queue))))
  queue))

;; Exercise 3.12-3.20 - Various mutable structure exercises
;; Table implementation
(def! make-table (fn* []
  (atom {})))

(def! lookup (fn* [key table]
  (get @table key nil)))

(def! insert! (fn* [key value table]
  (swap! table assoc key value)
  'ok))
#+end_src

** Section 3.5 - Streams

#+begin_src lisp :tangle ./chapter3_streams.mal
;; SICP 3.5 - Streams (lazy lists)
;; MAL doesn't have built-in delay/force, so we'll simulate

;; Delay and force implementation
(def! delay (fn* [exp]
  (let* [already-run? (atom false)
         result (atom nil)]
    (fn* []
      (if (not @already-run?)
          (do (reset! result exp)
              (reset! already-run? true)))
      @result))))

(def! force (fn* [delayed-object]
  (delayed-object)))

;; Stream implementation
(def! the-empty-stream '())
(def! stream-null? empty?)

(def! cons-stream (fn* [a b]
  (cons a (delay b))))

(def! stream-car first)
(def! stream-cdr (fn* [stream]
  (force (rest stream))))

;; Stream operations
(def! stream-ref (fn* [s n]
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1)))))

(def! stream-map (fn* [proc s]
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s))))))

(def! stream-for-each (fn* [proc s]
  (if (not (stream-null? s))
      (do (proc (stream-car s))
          (stream-for-each proc (stream-cdr s))))))

(def! display-stream (fn* [s]
  (stream-for-each println s)))

(def! stream-enumerate-interval (fn* [low high]
  (if (> low high)
      the-empty-stream
      (cons-stream low
                   (stream-enumerate-interval (+ low 1) high)))))

;; Infinite streams
(def! integers-starting-from (fn* [n]
  (cons-stream n (integers-starting-from (+ n 1)))))

(def! integers (integers-starting-from 1))

;; Sieve of Eratosthenes
(def! divisible? (fn* [x y]
  (= (mod x y) 0)))

(def! sieve (fn* [stream]
  (cons-stream
    (stream-car stream)
    (sieve (stream-filter
             (fn* [x]
               (not (divisible? x (stream-car stream))))
             (stream-cdr stream))))))

(def! primes (sieve (integers-starting-from 2)))
#+end_src

* SICP Chapter 4 - Metalinguistic Abstraction

** The Metacircular Evaluator

#+begin_src lisp :tangle ./chapter4_evaluator.mal
;; SICP 4.1 - The Metacircular Evaluator
;; A Lisp interpreter written in Lisp (MAL)

;; Expression types
(def! self-evaluating? (fn* [exp]
  (or (number? exp) (string? exp))))

(def! variable? symbol?)

(def! quoted? (fn* [exp]
  (and (list? exp) (= (first exp) 'quote))))

(def! text-of-quotation (fn* [exp] (nth exp 1)))

(def! assignment? (fn* [exp]
  (and (list? exp) (= (first exp) 'set!))))

(def! assignment-variable (fn* [exp] (nth exp 1)))
(def! assignment-value (fn* [exp] (nth exp 2)))

(def! definition? (fn* [exp]
  (and (list? exp) (= (first exp) 'define))))

(def! definition-variable (fn* [exp]
  (if (symbol? (nth exp 1))
      (nth exp 1)
      (first (nth exp 1)))))

(def! definition-value (fn* [exp]
  (if (symbol? (nth exp 1))
      (nth exp 2)
      (make-lambda (rest (nth exp 1))
                   (rest (rest exp))))))

(def! lambda? (fn* [exp]
  (and (list? exp) (= (first exp) 'lambda))))

(def! lambda-parameters (fn* [exp] (nth exp 1)))
(def! lambda-body (fn* [exp] (rest (rest exp))))

(def! make-lambda (fn* [parameters body]
  (cons 'lambda (cons parameters body))))

(def! if? (fn* [exp]
  (and (list? exp) (= (first exp) 'if))))

(def! if-predicate (fn* [exp] (nth exp 1)))
(def! if-consequent (fn* [exp] (nth exp 2)))
(def! if-alternative (fn* [exp]
  (if (> (count exp) 3)
      (nth exp 3)
      'false)))

(def! begin? (fn* [exp]
  (and (list? exp) (= (first exp) 'begin))))

(def! begin-actions (fn* [exp] (rest exp)))
(def! last-exp? (fn* [seq] (empty? (rest seq))))
(def! first-exp first)
(def! rest-exps rest)

(def! application? list?)
(def! operator first)
(def! operands rest)

;; Environment operations (simplified)
(def! enclosing-environment (fn* [env] (:outer env)))
(def! first-frame (fn* [env] env))
(def! the-empty-environment {})

(def! make-frame (fn* [variables values]
  (zipmap (map str variables) values)))

(def! frame-variables (fn* [frame] (keys frame)))
(def! frame-values (fn* [frame] (vals frame)))

(def! add-binding-to-frame! (fn* [var val frame]
  (assoc frame (str var) val)))

(def! extend-environment (fn* [vars vals base-env]
  (if (= (count vars) (count vals))
      (assoc (make-frame vars vals) :outer base-env)
      (if (< (count vars) (count vals))
          (throw "Too many arguments supplied")
          (throw "Too few arguments supplied")))))

(def! lookup-variable-value (fn* [var env]
  (let* [var-str (str var)]
    (if (contains? env var-str)
        (get env var-str)
        (if (contains? env :outer)
            (lookup-variable-value var (:outer env))
            (throw (str "Unbound variable: " var)))))))

(def! set-variable-value! (fn* [var val env]
  (let* [var-str (str var)]
    (if (contains? env var-str)
        (assoc env var-str val)
        (if (contains? env :outer)
            (set-variable-value! var val (:outer env))
            (throw (str "Unbound variable -- SET!: " var)))))))

(def! define-variable! (fn* [var val env]
  (assoc env (str var) val)))

;; Evaluator
(def! eval-sicp (fn* [exp env]
  (cond (self-evaluating? exp) exp
        (variable? exp) (lookup-variable-value exp env)
        (quoted? exp) (text-of-quotation exp)
        (assignment? exp) (eval-assignment exp env)
        (definition? exp) (eval-definition exp env)
        (if? exp) (eval-if exp env)
        (lambda? exp)
          (make-procedure (lambda-parameters exp)
                          (lambda-body exp)
                          env)
        (begin? exp)
          (eval-sequence (begin-actions exp) env)
        (application? exp)
          (apply-sicp (eval-sicp (operator exp) env)
                      (list-of-values (operands exp) env))
        :else
          (throw (str "Unknown expression type -- EVAL: " exp)))))

(def! apply-sicp (fn* [procedure arguments]
  (cond (primitive-procedure? procedure)
          (apply-primitive-procedure procedure arguments)
        (compound-procedure? procedure)
          (eval-sequence
            (procedure-body procedure)
            (extend-environment
              (procedure-parameters procedure)
              arguments
              (procedure-environment procedure)))
        :else
          (throw "Unknown procedure type -- APPLY"))))

(def! list-of-values (fn* [exps env]
  (if (empty? exps)
      '()
      (cons (eval-sicp (first exps) env)
            (list-of-values (rest exps) env)))))

(def! eval-if (fn* [exp env]
  (if (true? (eval-sicp (if-predicate exp) env))
      (eval-sicp (if-consequent exp) env)
      (eval-sicp (if-alternative exp) env))))

(def! eval-sequence (fn* [exps env]
  (if (last-exp? exps)
      (eval-sicp (first-exp exps) env)
      (do (eval-sicp (first-exp exps) env)
          (eval-sequence (rest-exps exps) env)))))

(def! eval-assignment (fn* [exp env]
  (set-variable-value! (assignment-variable exp)
                       (eval-sicp (assignment-value exp) env)
                       env)
  'ok))

(def! eval-definition (fn* [exp env]
  (define-variable! (definition-variable exp)
                    (eval-sicp (definition-value exp) env)
                    env)
  'ok))

;; Procedures
(def! make-procedure (fn* [parameters body env]
  (list 'procedure parameters body env)))

(def! compound-procedure? (fn* [p]
  (and (list? p) (= (first p) 'procedure))))

(def! procedure-parameters (fn* [p] (nth p 1)))
(def! procedure-body (fn* [p] (nth p 2)))
(def! procedure-environment (fn* [p] (nth p 3)))

;; Primitive procedures (simplified)
(def! primitive-procedure? (fn* [proc]
  (contains? primitive-procedures proc)))

(def! primitive-procedures
  {+ + - - * * / / = = < < > >})

(def! apply-primitive-procedure (fn* [proc args]
  (apply (get primitive-procedures proc) args)))

(def! true? (fn* [x] (not (false? x))))
(def! false? (fn* [x] (= x false)))

;; Setup and test
(def! setup-environment (fn* []
  (let* [initial-env (extend-environment 
                       (keys primitive-procedures)
                       (vals primitive-procedures)
                       the-empty-environment)]
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env)))

(def! the-global-environment (setup-environment))
#+end_src

* Testing and Examples

** Test Runner

#+begin_src lisp :tangle ./run_tests.mal
;; SICP Examples Test Runner
;; Run all examples and verify functionality

(println "Loading SICP Examples...")
(println "========================\n")

;; Chapter 1
(println "Chapter 1 - Building Abstractions with Procedures")
(println "-------------------------------------------------")
(load-file "chapter1_basics.mal")
(load-file "chapter1_conditionals.mal")
(load-file "chapter1_recursion.mal")
(println (str "  factorial(5) = " (factorial 5)))
(println (str "  fibonacci(10) = " (fib 10)))
(load-file "chapter1_tree_recursion.mal")
(println (str "  count-change(100) = " (count-change 100)))
(load-file "chapter1_higher_order.mal")
(println (str "  pi approximation = " (* 8 (pi-sum 1 10000))))
(load-file "chapter1_lambda.mal")
(load-file "chapter1_procedures_as_values.mal")
(println (str "  sqrt(2) = " (sqrt-newton 2)))

;; Chapter 2
(println "\nChapter 2 - Building Abstractions with Data")
(println "--------------------------------------------")
(load-file "chapter2_church_numerals.mal")
(test-church-numerals)
(load-file "chapter2_pairs.mal")
(println (str "  Procedural pair test: " 
              (car-proc (cons-proc 1 2))))
(load-file "chapter2_lists.mal")
(println (str "  Reverse '(1 2 3 4) = " (reverse '(1 2 3 4))))
(load-file "chapter2_trees.mal")
(println (str "  Count leaves '((1 2) (3 4)) = " 
              (count-leaves '((1 2) (3 4)))))
(load-file "chapter2_symbolic.mal")
(test-deriv)

;; Chapter 3
(println "\nChapter 3 - Modularity, Objects, and State")
(println "-------------------------------------------")
(load-file "chapter3_state.mal")
(def! acc (make-account 100))
(println (str "  Account withdraw 50: " ((acc 'withdraw) 50)))
(println (str "  Account balance: " (acc 'balance)))

;; Chapter 4
(println "\nChapter 4 - Metalinguistic Abstraction")
(println "---------------------------------------")
(load-file "chapter4_evaluator.mal")
(println "  Metacircular evaluator loaded")
(println (str "  eval '(+ 1 2) = " 
              (eval-sicp '(+ 1 2) the-global-environment)))

(println "\nAll SICP examples loaded successfully! ðŸŽ‰")
#+end_src

** Makefile Integration

#+begin_src makefile :tangle ./Makefile
# SICP Examples Makefile

.PHONY: all test clean

all: test

test:
	@echo "Running SICP examples in MAL..."
	@cd ../.. && ./stepA_mal.rb experiments/005-sicp-mal/run_tests.mal

individual-tests:
	@echo "Testing Chapter 1..."
	@cd ../.. && ./stepA_mal.rb experiments/005-sicp-mal/chapter1_basics.mal
	@cd ../.. && ./stepA_mal.rb experiments/005-sicp-mal/chapter1_recursion.mal
	@echo "Testing Chapter 2..."
	@cd ../.. && ./stepA_mal.rb experiments/005-sicp-mal/chapter2_church_numerals.mal
	@cd ../.. && ./stepA_mal.rb experiments/005-sicp-mal/chapter2_symbolic.mal

clean:
	@echo "Cleaning generated files..."
	@rm -f *.png

tangle:
	@echo "Tangling org files..."
	@emacs --batch -l org --eval "(org-babel-tangle-file \"SETUP.org\")"
#+end_src

** Usage Instructions

#+begin_src text :tangle ./README.md
# SICP Examples in MAL

This directory contains SICP (Structure and Interpretation of Computer Programs) 
examples translated to MAL's Lisp dialect.

## Structure

- `chapter1_*.mal` - Building Abstractions with Procedures
- `chapter2_*.mal` - Building Abstractions with Data  
- `chapter3_*.mal` - Modularity, Objects, and State
- `chapter4_*.mal` - Metalinguistic Abstraction
- `run_tests.mal` - Test runner for all examples

## Running Examples

From the main MAL directory:

```bash
# Run all tests
./stepA_mal.rb experiments/005-sicp-mal/run_tests.mal

# Run individual chapter
./stepA_mal.rb experiments/005-sicp-mal/chapter1_basics.mal

# Interactive exploration
./stepA_mal.rb
user> (load-file "chapter2_church_numerals.mal")
user> (church->int (church-add church-two church-three))
5
```

## Key Differences from Scheme

- `def!` instead of `define`
- `fn*` instead of `lambda`
- `let*` instead of `let`
- Atoms for mutable state instead of `set!`
- Built-in hash maps instead of association lists

## Topics Covered

1. **Chapter 1**: Procedures, recursion, higher-order functions
2. **Chapter 2**: Data abstraction, Church encodings, symbolic computation
3. **Chapter 3**: State, mutation, streams (lazy evaluation)
4. **Chapter 4**: Metacircular evaluator, language interpretation

Enjoy exploring SICP concepts in MAL!
#+end_src
