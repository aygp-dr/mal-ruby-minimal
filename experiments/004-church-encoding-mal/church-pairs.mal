;; Church Encoding: Pairs and Lists in Pure Lambda Calculus
;; Demonstrates the connection to our cons cell implementation

;; Load dependencies
(load-file "church-booleans.mal")

;; Core Church Pair (matches our presentation exactly!)
(def! church-pair (fn* (a b) 
  (fn* (f) (f a b))))

;; Projection functions - extract first and second elements
(def! church-first (fn* (p) 
  (p (fn* (x y) x))))

(def! church-second (fn* (p) 
  (p (fn* (x y) y))))

;; Demonstrate equivalence with our cons cells
(def! validate-pair-equivalence (fn* (a b)
  (let* (church-p (church-pair a b)
         regular-p (cons a b))
    (do
      (println "ðŸ”— Validating Church pair equivalence:")
      (println "  Church first:", (church-first church-p))
      (println "  Regular car:", (car regular-p))
      (println "  Church second:", (church-second church-p))
      (println "  Regular cdr:", (cdr regular-p))
      (and (= (church-first church-p) (car regular-p))
           (= (church-second church-p) (cdr regular-p)))))))

;; Church Lists using pairs
(def! church-nil church-false)  ; Empty list is false

(def! church-cons (fn* (head tail)
  (church-pair church-false (church-pair head tail))))

;; List operations
(def! church-head (fn* (lst) 
  (church-first (church-second lst))))

(def! church-tail (fn* (lst) 
  (church-second (church-second lst))))

(def! church-nil? (fn* (lst) 
  (church-first lst)))

;; Convert Church list to MAL list
(def! church->list (fn* (cl)
  (if (church->bool (church-nil? cl))
    nil
    (cons (church-head cl) 
          (church->list (church-tail cl))))))

;; Convert MAL list to Church list
(def! list->church (fn* (lst)
  (if (nil? lst)
    church-nil
    (church-cons (car lst) (list->church (cdr lst))))))

;; Church list length
(def! church-length (fn* (lst)
  (if (church->bool (church-nil? lst))
    church-zero
    (church-succ (church-length (church-tail lst))))))

;; Church list append
(def! church-append (fn* (lst1 lst2)
  (if (church->bool (church-nil? lst1))
    lst2
    (church-cons (church-head lst1) 
                 (church-append (church-tail lst1) lst2)))))

;; Church list map
(def! church-map (fn* (f lst)
  (if (church->bool (church-nil? lst))
    church-nil
    (church-cons (f (church-head lst))
                 (church-map f (church-tail lst))))))

;; Church list fold
(def! church-fold (fn* (f acc lst)
  (if (church->bool (church-nil? lst))
    acc
    (church-fold f 
                 (f acc (church-head lst))
                 (church-tail lst)))))

;; Test framework for Church pairs and lists
(def! test-church-pairs (fn* ()
  (do
    (println "ðŸ‘« Testing Church Pair Encodings...")
    
    ;; Basic pair operations
    (let* (p (church-pair 42 "hello"))
      (println "Testing basic pairs:")
      (println "  first(pair(42, 'hello')) ->", (church-first p))
      (println "  second(pair(42, 'hello')) ->", (church-second p)))
    
    ;; Validate equivalence with cons cells
    (println "Validating equivalence with cons cells:")
    (println "  Equivalence check ->", (validate-pair-equivalence 1 2))
    
    ;; Church list operations
    (println "Testing Church lists:")
    (let* (cl1 (church-cons 1 (church-cons 2 (church-cons 3 church-nil)))
           cl2 (list->church '(4 5 6))
           mal-list (church->list cl1))
      (println "  Church list [1,2,3] -> MAL:", mal-list)
      (println "  MAL list [4,5,6] -> Church -> MAL:", (church->list cl2))
      (println "  Length of [1,2,3]:", (church->num (church-length cl1)))
      (println "  Append [1,2,3] + [4,5,6]:", 
               (church->list (church-append cl1 cl2))))
    
    ;; Higher-order operations
    (println "Testing higher-order list operations:")
    (let* (numbers (list->church '(1 2 3))
           doubled (church-map (fn* (x) (* x 2)) numbers)
           sum (church-fold + 0 numbers))
      (println "  Map double over [1,2,3]:", (church->list doubled))
      (println "  Fold + over [1,2,3]:", sum))
    
    (println "âœ… Church Pair and List tests complete!"))))

;; Demonstrate the theoretical foundation
(def! demonstrate-pair-theory (fn* ()
  (do
    (println "ðŸŽ“ Church Pair Theoretical Demonstration:")
    (println "Our cons cells are Church pairs!")
    (println "This proves our implementation captures lambda calculus essence.")
    
    ;; Show the mathematical equivalence
    (println "\nMathematical equivalence:")
    (println "  Church pair: Î»a.Î»b.Î»f.f a b")
    (println "  Our cons: Creates object with car/cdr methods")  
    (println "  Both encode: 'Select from two values using a function'")
    
    ;; Demonstrate composition
    (let* (nested (church-pair (church-pair 1 2) (church-pair 3 4)))
      (println "\nNested pairs work perfectly:")
      (println "  ((1,2),(3,4)) first first:", 
               (church-first (church-first nested)))
      (println "  ((1,2),(3,4)) second second:", 
               (church-second (church-second nested))))
    
    (println "\nThis validates our 'extreme constraints' architectural choice!"))))

;; Run the demonstrations
(test-church-pairs)
(demonstrate-pair-theory)